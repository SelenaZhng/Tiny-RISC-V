#!/usr/bin/env python
#=========================================================================
# imul-sim [options]
#=========================================================================
#
#  -h --help           Display this message
#
#  --impl              {fl,base,alt}
#  --input dataset     {small,large,lomask,himask,lohimask,sparse}
#  --trace             Display line tracing
#  --stats             Display statistics
#  --dump-vcd          Dump VCD to imul-<impl>-<input>.vcd
#
# Author : Christopher Batten, Shunning Jiang
# Date   : February 5, 2015
#

# Hack to add project root to python path

import os
import sys

sim_dir = os.path.dirname( os.path.abspath( __file__ ) )
while sim_dir:
  if os.path.exists( sim_dir + os.path.sep + "pymtl.ini" ):
    sys.path.insert(0,sim_dir)
    break
  sim_dir = os.path.dirname(sim_dir)

import argparse
import re

from random import randint, seed

seed(0xdeadbeef)

from pymtl3 import *
from pymtl3.stdlib.test_utils import config_model_with_cmdline_opts
from pymtl3.passes.backends.verilog import VerilogPlaceholderPass

from lab1_imul.IntMulFL   import IntMulFL
from lab1_imul.IntMulBase import IntMulBase
from lab1_imul.IntMulAlt  import IntMulAlt

from lab1_imul.test.IntMulFL_test import TestHarness

#-------------------------------------------------------------------------
# mk_imsg/mk_omsg
#-------------------------------------------------------------------------

# Make input message, truncate ints to ensure they fit in 32 bits.

def mk_imsg( a, b ):
  return concat( Bits32( a, trunc_int=True ), Bits32( b, trunc_int=True ) )

# Make output message, truncate ints to ensure they fit in 32 bits.

def mk_omsg( a ):
  return Bits32( a, trunc_int=True )

#----------------------------------------------------------------------
# Data Set: random small
#----------------------------------------------------------------------

random_small_msgs = []
for i in range(50):
  a = randint(-2147483648,4294967295)
  b = randint(-2147483648,4294967295)
  random_small_msgs.extend([ mk_imsg( a, b ), mk_omsg( a * b ) ])

random_mixed_msgs = []
for i in range(50):
  a = randint(-2147483648,4294967295)
  b = randint(-2147483648,4294967295)
  random_mixed_msgs.extend([ mk_imsg( a, b ), mk_omsg( a * b ) ])
#"large", "sparse", "dense", "rand_fast"
random_large_msgs = []
for i in range(50):
  a = randint(-2147483648,4294967295)
  b = randint(-2147483648,4294967295)
  random_large_msgs.extend([ mk_imsg( a, b ), mk_omsg( a * b ) ])

random_sparse_msgs = []
for i in range(50):
  a = randint(-2147483648,4294967295)
  b = randint(-2147483648,4294967295)
  random_sparse_msgs.extend([ mk_imsg( a, b ), mk_omsg( a * b ) ])

random_dense_msgs = []
for i in range(50):
  a = randint(-2147483648,4294967295)
  b = randint(-2147483648,4294967295)
  random_dense_msgs.extend([ mk_imsg( a, b ), mk_omsg( a * b ) ])

random_densevssparse_msgs = []
for i in range(50):
  a = randint(-2147483648,4294967295)
  b = randint(-2147483648,4294967295)
  random_densevssparse_msgs.extend([ mk_imsg( a, b ), mk_omsg( a * b ) ])

# ---------- helpers that make B the thing that varies ----------
from random import randint

def build_msgs_for_b( patterns_b, n_repeat=1, a_lo=-(1<<31), a_hi=(1<<31)-1 ):
  msgs = []
  for b in patterns_b:
    for _ in range(n_repeat):
      a = randint(a_lo, a_hi)
      msgs.extend([ mk_imsg(a,b), mk_omsg(a*b) ])
  return msgs

def build_msgs_fixed_b( n, b_val, a_lo=-(1<<31), a_hi=(1<<31)-1, seed_base=0xDEC0DE ):
  from random import seed
  seed(seed_base + (b_val & 0xFFFF))
  msgs = []
  for _ in range(n):
    a = randint(a_lo, a_hi)
    msgs.extend([ mk_imsg(a,b_val), mk_omsg(a*b_val) ])
  return msgs

# ---------- new datasets that reveal variable latency ----------
b_edges_msgs = build_msgs_for_b([
  0x00000000, 0x00000001, 0x80000000, 0x00000002, 0x00010000
], n_repeat=6)

b_powers_msgs = build_msgs_for_b([1<<k for k in [0,1,2,3,4,5,7,8,12,16,20,24,28,31]], n_repeat=4)

b_dense_msgs  = build_msgs_for_b([
  0xFFFFFFFF, 0x7FFFFFFF, 0xFFFFFFFE, 0xAAAAAAAA, 0x55555555, 0xFFFF000F,
  0xF0F0F0F0, 0x0F0F0F0F
], n_repeat=6)

b_low_ones_msgs = build_msgs_for_b([0x0000FFFF, 0x00000FFF, 0x000000FF, 0x0000000F], n_repeat=8)

b_run_skip_msgs = build_msgs_for_b([
  0x00000008, 0x00008000, 0x40000000, 0x00010001, 0x01000010
], n_repeat=6)

# two buckets for clean avg-cycle comparison (same A distribution, diff B sparsity)
b_sparse_bucket_msgs = build_msgs_for_b([1<<k for k in range(0,32,3)], n_repeat=6)
b_dense_bucket_msgs  = build_msgs_for_b([0xFFFFFFFF,0x7FFFFFFF,0xAAAAAAAA,0x55555555,0xFFFF000F,0xF0F0F0F0], n_repeat=6)

# random A with fixed B
rand_B_zero_msgs     = build_msgs_fixed_b(20, 0x00000000)
rand_B_one_msgs      = build_msgs_fixed_b(20, 0x00000001)
rand_B_allones_msgs  = build_msgs_fixed_b(20, 0xFFFFFFFF)
rand_B_altA_msgs     = build_msgs_fixed_b(20, 0xAAAAAAAA)
rand_B_alt5_msgs     = build_msgs_fixed_b(20, 0x55555555)
rand_B_power_hi_msgs = build_msgs_fixed_b(20, 0x80000000)

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--impl", default="fl",
    choices=["fl","base","alt"] )

  # ''' LAB TASK '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  # Add more choices below for the --input command line option. There
  # should be one choice for each input dataset that you defined above.
  # ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

  p.add_argument( "--input", default="small",
    choices=[
    "small","mixed","large","sparse","dense","densevssparse",
    "b_edges","b_powers","b_dense","b_low_ones","b_run_skip",
    "b_sparse_bucket","b_dense_bucket",
    "rand_B_zero","rand_B_one","rand_B_allones","rand_B_altA","rand_B_alt5","rand_B_power_hi",
  ] )

  p.add_argument( "--trace",     action="store_true" )
  p.add_argument( "--stats",     action="store_true" )
  p.add_argument( "--translate", action="store_true" )
  p.add_argument( "--dump-vcd",  action="store_true" )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------

def main():
  opts = parse_cmdline()

  # Create the input pattern

  inputs  = None

  # ''' LAB TASK '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  # Use additional if statements to set the inputs appropriately based on
  # the --input command line option.
  # ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  
  if opts.input == "small":
    inputs = random_small_msgs
  elif opts.input == "mixed":
    inputs = random_mixed_msgs
  elif opts.input == "large":
    inputs = random_large_msgs
  elif opts.input == "sparse":
    inputs = random_sparse_msgs
  elif opts.input == "dense":
    inputs = random_dense_msgs
  elif opts.input == "densevssparse":
    inputs = random_densevssparse_msgs
  elif opts.input == "b_edges":
    inputs = b_edges_msgs
  elif opts.input == "b_powers":
    inputs = b_powers_msgs
  elif opts.input == "b_dense":
    inputs = b_dense_msgs
  elif opts.input == "b_low_ones":
    inputs = b_low_ones_msgs
  elif opts.input == "b_run_skip":
    inputs = b_run_skip_msgs
  elif opts.input == "b_sparse_bucket":
    inputs = b_sparse_bucket_msgs
  elif opts.input == "b_dense_bucket":
    inputs = b_dense_bucket_msgs
  elif opts.input == "rand_B_zero":
    inputs = rand_B_zero_msgs
  elif opts.input == "rand_B_one":
    inputs = rand_B_one_msgs
  elif opts.input == "rand_B_allones":
    inputs = rand_B_allones_msgs
  elif opts.input == "rand_B_altA":
    inputs = rand_B_altA_msgs
  elif opts.input == "rand_B_alt5":
    inputs = rand_B_alt5_msgs
  elif opts.input == "rand_B_power_hi":
    inputs = rand_B_power_hi_msgs

  
  

  ninputs = len(inputs[::2])

  # Determine which model to use in the simulator

  model_impl_dict = {
    "fl"  : IntMulFL,
    "base": IntMulBase,
    "alt" : IntMulAlt,
  }

  # Check if translation is valid

  if opts.translate and not opts.impl.startswith("rtl"):
    print("\n ERROR: --translate only works with RTL models \n")
    exit(1)

  # Create test harness (we can reuse the harness from unit testing)

  th = TestHarness( model_impl_dict[ opts.impl ]() )

  th.set_param( "top.src.construct",  msgs=inputs[::2]  )
  th.set_param( "top.sink.construct", msgs=inputs[1::2] )

  # Create VCD filename

  unique_name = f"imul-{opts.impl}-{opts.input}"

  cmdline_opts = {
    'dump_vcd': f"{unique_name}" if opts.dump_vcd else '',
    'test_verilog': 'zeros' if opts.translate else '',
  }

  # Configure the test harness component

  config_model_with_cmdline_opts( th, cmdline_opts, duts=['imul'] )

  # Apply necessary passes

  th.apply( DefaultPassGroup( linetrace=opts.trace ) )

  # Reset test harness

  th.sim_reset()

  # Run simulation

  while not th.done():
    th.sim_tick()

  # Extra ticks to make VCD easier to read

  th.sim_tick()
  th.sim_tick()
  th.sim_tick()

  # Display statistics

  if opts.stats:
    print( f"num_cycles         = {th.sim_cycle_count()}" )
    print( f"num_cycles_per_mul = {th.sim_cycle_count()/(1.0*ninputs):1.2f}" )

main()

